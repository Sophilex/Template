# 容斥原理

设$S$是一个有限集，$A_1,A_2...A_n是S的n个子集$，则

$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...<j_i \leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

## 基本应用：

---

m件不同的物品，分给n个人，要求每一个人至少分得一件物品，求不同的分配方案数

令$A_i$表示第i个人没有物品，S表示m个物品分给n个人的总方案数

则$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...<j_i\leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}(n-i)^m$

---

有 $2n 个元素 a_1,a_2, ...,a_n 和 b_1,b_2, ...,b_n$，求有多少个它们的全排列，满足任意的

$1 ≤i≤n， a_i 和 b_i$ 都不相邻。

同样的，令$A_i$表示$a_i和b_i$相邻，

则$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...j_i \leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}|有i对相邻的方案数|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}2^i*(2n-i)!$

---

[23HDU Cargo]: http://acm.hdu.edu.cn/contest/problem?cid=1102&pid=1011

大意：

n家店，每家店卖一种商品，总共有m种商品在卖。k次操作，每次随机选择一家店并且买下对应种类的商品。对于每一种商品i，记ci为售卖该种商品的店数，如果k次操作手里刚好有ci种i商品，且分别来自不同的店，则该商品合法。问k次操作之后所有种类的商品都不合法的方案数%998244353

$n,m\leq 1e5,k<998244353$

思路：

可能数据范围并不是很支持直接容斥，但是可以发现基本上就是容斥的样子，所以试试看优化容斥。

令$A_i$表示第种商品合法的方案数，

则$|S-\bigcup_{i=1}^{m}A_i|=\sum_{i=0}^{m}(-1)^i\sum_{1\leq j_1< j_2...j_i}|\bigcap_{k=1}^{i}A_{j_k}|$

只考虑$A_i$，方案数为$A_{n}^{c_i}(n-c_i)^{k-c_i}$,意义显然。多个$A_i$取交的话，方案数就是$A_{n}^{\sum c_i}(n-\sum c_i)^{k-\sum c_i}$

发现这个方案数只与$\sum c_i$有关，而与顺序，某一个具体值无关，所以我们可以改变一下思路，转为枚举$\sum c_i$

具体来说，对于每一个$\sum c_i=j$,它的贡献就是用偶数个$c_i$累加得到j的方案数减去用奇数个$c_i$累加得到j的方案数，（这一步其实就是容斥原理公式的转化）

既然如此，我们考虑生成函数$1-x^{c_i}$，表示对于每一个$c_i$，取一个数得到和为$c_i$的方案数为-1，这是因为1是一个奇数，那么显然，在$\prod (1-x^{c_i})$中，如果某一个指数是由偶数个数累加得到的，其系数自然会是正数，奇数同理。由此该生成函数就满足了我们的条件，我们只要对每一项$[x_j](\prod (1-x^{c_i}))$乘上对应的方案数系数$A_{n}^{\sum c_i}(n-\sum c_i)^{k-\sum c_i}$即可.

个人感觉这种题目应该还是有点套路可循的，因为如果数据范围小一点的话，就是明显显的容斥，然后找到性质用生成函数来优化就不是那么难想到的了





[18青岛G](https://codeforces.com/gym/104270/problem/G)

大意：
给定一个由0,1，2组成的长度为n的数列，每次操作可以选择一个不含2的连续区间，将其中所有元素置为0.求**恰好操作m次**并且所有2都被消除的方案数,$n\leq 100,m\leq 10^9$
思路：

不妨记一个不含1的连续区间是一个合法区间，那么仔细观察一下，对于一个长度为$len$的合法区间，其操作的合法区间数是$\binom{len}{2}+len=\frac{len(len+1)}{2}$，所以其答案就是$(\frac{len(len+1)}{2})^m$,是可以$O(1)$计算得到的。这启示我们使用容斥来处理该问题 ，令$A_i$表示从左往右数第$i$个2没有消除的方案数，要求$ans=|S-A_1\bigcup A_2...\bigcup A_x|=\sum_{i=0}^{x}(-1)^i|A_{j_1}\bigcap A_{j_2}...\bigcap A_{j_i}|$
但是显然数据范围并不允许我们直接暴力枚举，所以考虑dp优化（很常见的思路）。

显然$|A_{j_1}\bigcap A_{j_2}...\bigcap A_{j_i}|$前面的系数由$i$，也就是不消除的2的个数决定,如果是奇数，系数就是-1，并且此时其他的2是不能消除的。所以不妨记$dp_{i,k,0/1}$表示前i个位置，合法操作区间数为k，总共有奇数/偶数个不能消除的2

为了方便计算，令$a_0=a_{n+1}=1$,这不会影响结果

那么最终我们的答案就是$\sum_{j=1}^{n(n+1)/2}(dp_{n+1,j,0}-dp_{n+1,j,1})j^m$,也就是枚举合法操作方案数为j的情况数

考虑转移，对于当前位置i，我们枚举上一个不消除的位置j，$pre_i\leq j<i,a_j=2$,其中$pre_i$表示i之前的第一个1的位置，因为1是一定不能消除的。此时$\large dp_{i,k+\frac{(i-j)(i-j+1)}{2},0/1}=\sum_{j=pre_i}^{i-1}dp_{j,k,1/0}$

最后总体复杂度$O(n^4+log(m))$

最后要特判一下1的个数，如果是奇数的话，显然改变了实际2的个数，所以答案要取负

```c++
ll dp[N][N*N][3];
ll n,m;
ll mas[N];
ll lim[N];//前i个点的最多的合法区间数
void solve()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) cin>>mas[i];
    mas[0]=mas[n+1]=1;
    dp[0][0][1]=1;dp[0][0][0]=0;lim[0]=0;
    ll pre=0;//上一个1的位置
    for(int i=1;i<=n+1;++i)
    {
        if(mas[i]==0) continue;
        lim[i]=lim[pre]+(i-pre)*(i-pre-1)/2;
        for (int j=0;j<=lim[i];++j) dp[i][j][0]=dp[i][j][1]=0;
        for(int j=pre;j<i;++j)
        {
            if(mas[j]==0) continue;
            ll add=(i-j)*(i-j-1)/2;
            for(int k=0;k<=lim[j];++k)
            {
                dp[i][k+add][0]=(dp[i][k+add][0]+dp[j][k][1])%mod;
                dp[i][k+add][1]=(dp[i][k+add][1]+dp[j][k][0])%mod;
            }
        }
        if(mas[i]==1) pre=i;
    }
    ll ans=0;
    for(int i=0;i<=lim[n+1];++i)
    {
        ll det=((dp[n+1][i][0]-dp[n+1][i][1])%mod+mod)%mod;
        ans=(ans+det*ksm(i,m)%mod)%mod;
    }

    ll cn=0;
    for(int i=1;i<=n;++i) if(mas[i]==1) cn++;
    if(cn%2) ans=(mod-ans)%mod;

    cout<<ans<<endl;
}
```










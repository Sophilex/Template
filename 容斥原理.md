# 容斥原理

设$S$是一个有限集，$A_1,A_2...A_n是S的n个子集$，则

$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...<j_i \leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

## 基本应用：

---

m件不同的物品，分给n个人，要求每一个人至少分得一件物品，求不同的分配方案数

令$A_i$表示第i个人没有物品，S表示m个物品分给n个人的总方案数

则$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...<j_i\leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}(n-i)^m$

---

有 $2n 个元素 a_1,a_2, ...,a_n 和 b_1,b_2, ...,b_n$，求有多少个它们的全排列，满足任意的

$1 ≤i≤n， a_i 和 b_i$ 都不相邻。

同样的，令$A_i$表示$a_i和b_i$相邻，

则$|S-\bigcup_{i=1}^{n}A_i|=\sum_{i=0}^{n}(-1)^i\sum_{1\leq j_1< j_2...j_i \leq n}|\bigcap_{k=1}^{i}A_{j_k}|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}|有i对相邻的方案数|$

$=\sum_{i=0}^{n}(-1)^i\binom{n}{i}2^i*(2n-i)!$

---

[23HDU Cargo]: http://acm.hdu.edu.cn/contest/problem?cid=1102&pid=1011

大意：

n家店，每家店卖一种商品，总共有m种商品在卖。k次操作，每次随机选择一家店并且买下对应种类的商品。对于每一种商品i，记ci为售卖该种商品的店数，如果k次操作手里刚好有ci种i商品，且分别来自不同的店，则该商品合法。问k次操作之后所有种类的商品都不合法的方案数%998244353

$n,m\leq 1e5,k<998244353$

思路：

可能数据范围并不是很支持直接容斥，但是可以发现基本上就是容斥的样子，所以试试看优化容斥。

令$A_i$表示第种商品合法的方案数，

则$|S-\bigcup_{i=1}^{m}A_i|=\sum_{i=0}^{m}(-1)^i\sum_{1\leq j_1< j_2...j_i}|\bigcap_{k=1}^{i}A_{j_k}|$

只考虑$A_i$，方案数为$A_{n}^{c_i}(n-c_i)^{k-c_i}$,意义显然。多个$A_i$取交的话，方案数就是$A_{n}^{\sum c_i}(n-\sum c_i)^{k-\sum c_i}$

发现这个方案数只与$\sum c_i$有关，而与顺序，某一个具体值无关，所以我们可以改变一下思路，转为枚举$\sum c_i$

具体来说，对于每一个$\sum c_i=j$,它的贡献就是用偶数个$c_i$累加得到j的方案数减去用奇数个$c_i$累加得到j的方案数，（这一步其实就是容斥原理公式的转化）

既然如此，我们考虑生成函数$1-x^{c_i}$，表示对于每一个$c_i$，取一个数得到和为$c_i$的方案数为-1，这是因为1是一个奇数，那么显然，在$\prod (1-x^{c_i})$中，如果某一个指数是由偶数个数累加得到的，其系数自然会是正数，奇数同理。由此该生成函数就满足了我们的条件，我们只要对每一项$[x_j](\prod (1-x^{c_i}))$乘上对应的方案数系数$A_{n}^{\sum c_i}(n-\sum c_i)^{k-\sum c_i}$即可.

个人感觉这种题目应该还是有点套路可循的，因为如果数据范围小一点的话，就是明显显的容斥，然后找到性质用生成函数来优化就不是那么难想到的了

code

```c++
#include <map>
#include <set>
#include <array>
#include <cmath>
#include <queue>
#include <stack>
#include <tuple>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <random>
#include <string>
#include <vector>
#include <cassert>
#include <cstring>
#include <iomanip>
#include <limits.h>
#include <iostream>
#include <algorithm>
#include <functional>
#include <unordered_map>
using namespace std;

#define N maxn
#define db double
#define il inline
#define fir first
#define sec second
#define eps (1e-8)
#define pb push_back
#define ll long long
#define mkp make_pair
#define eb emplace_back
#define pii pair<int, int>
#define lowbit(a) (a & (-a))
#define SZ(a) ((int)a.size())
#define ull unsigned long long
#define all(a) a.begin(), a.end()
#define split cout << "=========\n";
#define GG { cout << "NO\n"; return; }
#define pll pair<long long, long long>
#define equals(a, b) (fabs((a) - (b)) < eps)

constexpr int ON = 0;
constexpr int CW = -1;
constexpr int CCW = 1;
constexpr int BACK = 2;
constexpr int FRONT = -2;
const db pi = acos(-1.000);
constexpr int maxn = 2e5 + 50;
constexpr int INF = 0x3f3f3f3f;
constexpr ll LINF =  0x3f3f3f3f3f3f3f3f;
constexpr int mod = 998244353; /* 1e9 + 7 */
constexpr int dir[8][2] = {-1, 0, -1, 1, 0, 1, 1, 1, 1, 0, 1, -1, 0, -1, -1, -1};

mt19937_64 rnd(random_device {}());
uniform_int_distribution<ull> dist(0, ULLONG_MAX);//use dist(rnd)

bool BEGIN;
ll qpow(ll x,ll y)
{
    ll ans=1;
    while(y)
    {
        if(y&1) ans=ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}

namespace Poly
{
    #define mul(x, y) (1ll * x * y >= mod ? 1ll * x * y % mod : 1ll * x * y)
    #define minus(x, y) (1ll * x - y < 0 ? 1ll * x - y + mod : 1ll * x - y)
    #define plus(x, y) (1ll * x + y >= mod ? 1ll * x + y - mod : 1ll * x + y)//上面其实没用到
    #define ck(x) (x >= mod ? x - mod : x)//取模运算太慢了

    typedef vector<int> poly;
    const int G = 3;//根据具体的模数而定，原根可不一定不一样！！！
    //一般模数的原根为 2 3 5 7 10 6
    const int inv_G = qpow(G, mod - 2),tt = 22;
    int deer[2][tt][(1 << tt)];
    vector<int>RR(1 << (tt + 1), 0),inv(1 << tt, 0);

    void init(const int t) {//预处理出来NTT里需要的w和wn，砍掉了一个log的时间
        assert(t < tt);//一定要注意！！
        for(int p = 1; p <= t; ++ p) {
            int buf1 = qpow(G, (mod - 1) / (1 << p));
            int buf0 = qpow(inv_G, (mod - 1) / (1 << p));
            deer[0][p][0] = deer[1][p][0] = 1;
            for(int i = 1; i < (1 << p); ++ i) {
                deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆
                deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod;
            }
        }
        inv[1] = 1;
        for(int i = 2; i <= (1 << t); ++ i)
            inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod;
    }

    int NTT_init(int n) {//快速数论变换预处理
        int limit = 1, L = 0;
        while(limit <= n) limit <<= 1, L ++ ;
        assert(L < tt);
        assert(limit < 1 << (tt + 1));
        for(int i = 0; i < limit; ++ i)
            RR[i] = (RR[i >> 1] >> 1) | ((i & 1) << (L - 1));
        return limit;
    }

    void NTT(poly &A, bool type, int limit) {//快速数论变换
        A.resize(limit);
        for(int i = 0; i < limit; ++ i)
            if(i < RR[i])
                swap(A[i], A[RR[i]]);
        for(int mid = 2, j = 1; mid <= limit; mid <<= 1, ++ j) {
            int len = mid >> 1;
            for(int pos = 0; pos < limit; pos += mid) {
//                auto wn = deer[type][j].begin();
                for(int i = pos, p = 0; i < pos + len; ++ i, ++ p) {
                    int tmp = 1ll * deer[type][j][p] * A[i + len] % mod;
                    A[i + len] = ck(A[i] - tmp + mod);
                    A[i] = ck(A[i] + tmp);
                }
            }
        }
        if(type == 0) {
            for(int i = 0; i < limit; ++ i)
                A[i] = 1ll * A[i] * inv[limit] % mod;
        }
    }

    poly poly_mul(poly A, poly B) {//多项式乘法
        int deg = A.size() + B.size() - 1;
        int limit = NTT_init(deg);
        poly C(limit);
        NTT(A, 1, limit);
        NTT(B, 1, limit);
        for(int i = 0; i < limit; ++ i)
            C[i] = 1ll * A[i] * B[i] % mod;
        NTT(C, 0, limit);
        C.resize(deg);
        return C;
    }

    poly poly_inv(poly &f, int deg) {//多项式求逆 deg<f.szie()
        if(deg == 1)
            return poly(1, qpow(f[0], mod - 2));

        poly A(f.begin(), f.begin() + deg);
        poly B = poly_inv(f, (deg + 1) >> 1);
        int limit = NTT_init(deg << 1);
        NTT(A, 1, limit), NTT(B, 1, limit);
        for(int i = 0; i < limit; ++ i)
            A[i] = B[i] * (2 - 1ll * A[i] * B[i] % mod + mod) % mod;
        NTT(A, 0, limit);
        A.resize(deg);
        return A;
    }

    poly poly_dev(poly f) {//多项式求导
        int n = f.size();
        for(int i = 1; i < n; ++ i) f[i - 1] = 1ll * f[i] * i % mod;
        if(n > 1)f.resize(n - 1);
        else f[0] = 0;
        return f.resize(n - 1), f;//求导整体左移，第0项不要
    }

    poly poly_idev(poly f) {//多项式求积分
        int n = f.size();
        for(int i = n - 1; i ; -- i) f[i] = 1ll * f[i - 1] * inv[i] % mod;
        return f[0] = 0, f;//积分整体右移，第0项默认为0
    }

    poly poly_ln(poly f, int deg) {//多项式求对数，第一项为1
        poly A = poly_idev(poly_mul(poly_dev(f), poly_inv(f, deg)));
        return A.resize(deg), A;
    }

    poly poly_exp(poly &f, int deg) {//多项式求指数，第一项为0
        if(deg == 1)
            return poly(1, 1);

        poly B = poly_exp(f, (deg + 1) >> 1);
        B.resize(deg);
        poly lnB = poly_ln(B, deg);
        for(int i = 0; i < deg; ++ i)
            lnB[i] = ck(f[i] - lnB[i] + mod);

        int limit = NTT_init(deg << 1);//n -> n^2
        NTT(B, 1, limit), NTT(lnB, 1, limit);
        for(int i = 0; i < limit; ++ i)
            B[i] = 1ll * B[i] * (1 + lnB[i]) % mod;
        NTT(B, 0, limit);
        B.resize(deg);
        return B;
    }

    poly poly_pow(poly f, int k) {//多项式快速幂,第一项得是1
        f = poly_ln(f, f.size());
        for(auto &x : f) x = 1ll * x * k % mod;
        return poly_exp(f, f.size());
    }
     poly poly_ksm(poly f, int k,int m) {//多项式快速幂,适用于初始只有几项，同时所有项都需要的情况,会比上面那个快一点
        poly res(1, 1);
        while(k){
            if(k & 1)
                {
                    res = poly_mul(res, f);
                    res.resize(m,0);
                }
            f = poly_mul(f, f);
            f.resize(m,0);
            k >>= 1;
        }
        return res;
    }



}

using Poly::poly;
using Poly::poly_pow;
using Poly::poly_ksm;
using Poly::poly_mul;
using Poly::poly_inv;
vector<ll> vt;
poly poly_f(int l,int r,int num)
    {
        if(l>r)
        {
            return poly(1,1);
        }
        if(l==r)
        {
            poly ans(vt[l]+1,0);
            ans[0]=1;
            ans[vt[l]]=(mod-1)%mod;
            return ans;
        }
        int mid=(l+r)>>1;
        poly f = poly_f(l,mid,num);
        poly g = poly_f(mid+1,r,num);
        f = poly_mul(f,g);
        // f.resize(num+1);
        return f;
    }

ll p[N],pp[N],C[N];
void init(ll n)
{
    p[0]=1;
    for(ll i=1;i<=n;++i) p[i]=p[i-1]*i%mod;
    pp[1]=1;
    for(ll i=2;i<=n;++i)
    {
        pp[i]=(mod-mod/i)*pp[mod%i]%mod;
    }
    // for(ll i=1;i<=n;++i) C[i]=C[i-1]*qpow(i,mod-2)%mod*(k-i+1)%mod;
}
void init2(ll n,ll k)
{
    C[0]=1;
    for(ll i=1;i<=n;++i) C[i]=C[i-1]*pp[i]%mod*(k-i+1)%mod;
    for(int i=1;i<=n;++i) C[i]=C[i]*p[i]%mod;
}

ll n,m,k;
map<ll,ll> num1;
void solve()
{
    num1.clear();
    cin>>n>>m>>k;
    init2(max(n,m),k);
    // for(int i=0;i<=10;++i) cout<<C[i]<<' ';
    //     cout<<endl;
    for(int i=1;i<=n;++i)
    {
        ll a;cin>>a;
        num1[a]++;
    }

    vt.clear();
    for(auto i:num1) vt.push_back(i.second);
    Poly::init(20);
    poly f=poly_f(0,vt.size()-1,n);


    ll ans=0;
    for(ll i=0;i<=min(n,k);++i)
    {
        // cout<<f[i]<<' '<<C[i]<<" "<<qpow(n-i,k-i)<<endl;
        ans=((ans+f[i]*C[i]%mod*qpow(n-i,k-i)%mod)%mod+mod)%mod;
    }
    cout<<ans*qpow(qpow(n,k),mod-2)%mod<<endl;
}

bool END;
signed main() {
    // cout << fixed << setprecision(10);
    ios::sync_with_stdio(false); cin.tie(nullptr);
    init(200000);
    int T; cin >> T; while (T--)
    solve();
    // cout << ((&END - & BEGIN) >> 21) << '\n';
    return 0;
}

```














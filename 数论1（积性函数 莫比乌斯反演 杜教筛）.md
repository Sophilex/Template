# 积性函数

## 欧拉筛求普通积性函数

```c++
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll cal(ll x,ll num)
{
	//x为素数，num为其次数 
}
void jixing(ll n)
{
	f[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i])
		{
			p[++cnt]=i;
			f[i]=cal(i,1);
			cn[i]=1;
		}
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			//i*p[j]的最小质因子一定为p[j] 
			if(i%p[j]==0)
			{
				//i*p[j]的最小质因子的次数=i对应的p[j]的次数+1 
				cn[i*p[j]]=cn[i]+1;
				//首先去掉f[i]中p[j]对应的值,然后更新当前次数下p[j]对应的值 
				f[i*p[j]]=f[i]/cal(p[j],cnt[i])*cal(p[j],cnt[i]+1); 
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*cal(p[j],1);
		}
	}
} 
```

求因子个数

```c++
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll p[N];
ll f[N];
ll cnt=0;
void F(ll n)
{
	f[1]=1;
	cn[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i]) 
		{
			f[i]=2;
			p[++cnt]=i;
			cn[i]=1;
		}	
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			if(i%p[j]==0)
			{
				cn[i*p[j]]=cn[i]+1;
				f[i*p[j]]=f[i]/(cn[i]+1)*(cn[i]+2);
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*2;
		}
	}	
} 
```

# 莫比乌斯反演

形式1：

$f(n)=\sum_{d|n}g(d) \Leftrightarrow g(n)=\sum_{d|n}\mu(\frac{n}{d})f(d)$

形式2：

$f(n)=\sum_{n|m,m<=N}g(m) \Leftrightarrow g(n)=\sum_{n|m,m<=N}\mu(\frac{m}{n})f(m)$



# 杜教筛

其解决的问题：对数论函数f求前n项的前缀和$S(n)$，n可以达到$10^{10}$。其核心思想是构造另一个数论函数g，**使得$h=f*g$(狄利克雷卷积)能够$O(1)$地求前缀和**，并且**g本身也可以$O(1$地求某一点的值**。

但是它并不要求f一定要是一个积性函数，只需要能满足上述两个条件即可

在此基础上，我们可以在$\large O(n^{\frac{2}{3}})$的时间复杂度内得到前缀和，当然还需要预处理前$\large n^{\frac{2}{3}}$项的前缀和

一般来说，并杜教筛的实现只需要预处理前缀和，再加上整除分块即可，难点在于g函数的构造

下面进行推导

因为 $f∗g$的前缀和很好求，考虑用它去推得 $S(n)$

$\large ∑_{i=1}^{n}(f∗g)(i)=∑_{i=1}^{n}∑_{d|i}f(d)g(\frac{i}{d})$

$\large =∑_{d=1}^{n}g(d) \sum_{i=1}^{⌊\frac{n}{d}⌋}f(i)=\sum_{d=1}^{n}g(d)S(⌊\frac{n}{d}⌋)$

$\large ∴∑_{i=1}^{n}(f∗g)(i)=\sum_{d=1}^{n}g(d)S(⌊\frac{n}{d}⌋)$

$\large g(1)S(n)= \sum_{i=1}^{n}(f∗g)(i)-\sum_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)$

$\large S(n)=$$\Large \frac {\sum_{i=1}^{n}(f∗g)(i)-\sum_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)}{g(1)}$

这样就得到了$S(n)$的递推式

## 常见数论函数的前缀和推导[#](https://www.cnblogs.com/Rubyonly233/p/14925239.html#常见数论函数的前缀和推导)

- $f(n)=μ(n),S(n)=∑_{i=1}^{n}μ(i)$

构造函数$g(n)=1(n)$，容易得到 $f∗g=ϵ$套用公式

$S(n)=\Large \frac{∑_{i=1}^{n}(f∗g)(i)−∑_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)}{g(1)}$

$\Large =\frac{∑_{i=1}^{n}ϵ(i)−∑_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)}{g(1)}$

$\Large =\frac{1−∑_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)}{g(1)}$

$\Large =\frac{1−∑_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)}{1}=$$\large 1−∑_{d=2}^{n}g(d)S(⌊\frac{n}{d}⌋)$

因为 $g(n)=1(n)$，所以 $g(n)$ 的前缀和可以直接 $O(1)$ 求，至此所有条件就够了

------

- $f(n)=φ(n),S(n)=∑_{i=1}^{n}φ(i)$

构造函数 g(n)=1(n)，容易得到 $f∗g=id_1$,套用公式

![image-20230819162004418](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162004418.png)

同样可以套用模板去做

------

- $f(n)=μ(n)n,S(n)=∑_{i=1}^{n}μ(i)i$

构造函数 $g(n)=id_1(n)$

![image-20230819162034122](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162034122.png)

接着套用公式

![image-20230819162047244](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162047244.png)

因为 $g(n)=id_1(n)$，所以可以 $O(1)$ 计算前缀和，同样可以套用模板去做

------

- $f(n)=φ(n)n,S(n)=∑_{i=1}^{n}φ(i)i$

构造函数 $g(n)=id_1(n)$

![image-20230819162102054](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162102054.png)

接着套用公式

![image-20230819162114520](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162114520.png)

然后套用模板去做就行了

------

- $f(n)=μ(n)n^2,S(n)=∑_{i=1}^{n}μ(i)i^2$

构造函数 $g(n)=id_2(n)$

![image-20230819162147302](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162147302.png)

接着套用公式

![image-20230819162201844](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162201844.png)

因为 $g(n)=id_2(n)$，所以前缀和直接就是 $n(n+1)(2n+1)/6$，同样可以套用模板去做

------

- $f(n)=φ(n)n^2,S(n)=∑_{i=1}^{n}φ(i)i^2$

构造 $g(n)=id_2(n)$

![image-20230819162218451](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162218451.png)

接着套用公式

![image-20230819162229836](C:\Users\acm-673\AppData\Roaming\Typora\typora-user-images\image-20230819162229836.png)

$∑g(d)$的求法跟上面一样，接着还是套用模板去做就行了



[例子](http://acm.hdu.edu.cn/showproblem.php?pid=7325)

大意：给定$\large f(x)=(2^x-1)^k$,求$\large g(x)=\sum_{T=1}^{n}(\frac{n}{T})^2\sum_{d|T}f(d)\mu(\frac{T}{d})$,$n \leq 1e9$

考虑令$\large g(T)=\sum_{d|T}f(d)\mu(\frac{T}{d})$,$\large g$是$f$和$\mu$的狄利克雷卷积。如果可以快速求g的前缀和，我们就可以利用整除分块来解决这个式子。所以这是一道杜教筛套整除分块的经典例子

注意到f其实并不是一个积性函数，所以g也可能不是一个积性函数，但是并不影响我们构造对应的辅助函数

发现$g=f*\mu$,所以自然而然地考虑到$f=g*1$，f可以快速求前缀和，而$1(n)$函数也是无比友好，所以我们就可以利用它们进行构造了。

$\large S(n)=\sum_{i=1}^{n}g(i)=$$\Large \frac{\sum_{i=1}^{n}g*1-\sum_{i=2}^{n}1(i)S(n/i)}{1(1)}$

$\large =\sum_{i=1}^{n}f(i)-\sum_{i=2}^{n}S(n/i)$

最后考虑求f的前缀和

$\large \sum_{i=1}^{n}(2^i-1)^k=\sum_{i=1}^{n}\sum_{k=1}^{K}C(K,k)2^{ik}(-1)^{K-k}=\sum_{k=0}^{K}(-1)^{K-k}\sum_{i=1}^{n}2^{ik}$

后面一撮只要等比数列求和即可。特判一下k=0的情况，此时等比数列求和为n

最后我们的总体复杂度就是$O(n^{\frac{2}{3}}K)$

$ps:$感觉辅助函数的构造一般也不会太逆天，总归是有迹可循的，就像这里，把g与f反演就是一个及其自然的过程，包括上面的一些推导，也都不是空穴来风。最重要的还是积累，以及灵光一现。




# 积性函数

## 欧拉筛求普通积性函数

```
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll cal(ll x,ll num)
{
	//x为素数，num为其次数 
}
void jixing(ll n)
{
	f[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i])
		{
			p[++cnt]=i;
			f[i]=cal(i,1);
			cn[i]=1;
		}
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			//i*p[j]的最小质因子一定为p[j] 
			if(i%p[j]==0)
			{
				//i*p[j]的最小质因子的次数=i对应的p[j]的次数+1 
				cn[i*p[j]]=cn[i]+1;
				//首先去掉f[i]中p[j]对应的值,然后更新当前次数下p[j]对应的值 
				f[i*p[j]]=f[i]/cal(p[j],cnt[i])*cal(p[j],cnt[i]+1); 
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*cal(p[j],1);
		}
	}
} 
```

求因子个数

```
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll p[N];
ll f[N];
ll cnt=0;
void F(ll n)
{
	f[1]=1;
	cn[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i]) 
		{
			f[i]=2;
			p[++cnt]=i;
			cn[i]=1;
		}	
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			if(i%p[j]==0)
			{
				cn[i*p[j]]=cn[i]+1;
				f[i*p[j]]=f[i]/(cn[i]+1)*(cn[i]+2);
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*2;
		}
	}	
} 
```

# 莫比乌斯反演

形式1：

$f(n)=\sum_{d|n}g(d) \Leftrightarrow g(n)=\sum_{d|n}\mu(\frac{n}{d})f(d)$

形式2：

$f(n)=\sum_{n|m,m<=N}g(m) \Leftrightarrow g(n)=\sum_{n|m,m<=N}\mu(\frac{m}{n})f(m)$







# 杜教筛

其解决的基本问题是求一个数论函数$g$的前缀和，数据范围可以达到$10^{10}$

核心思想是构造一个数论函数$f$，使得$h=f*g$的前缀和以及f的某一项的值可以O(1)求出，它并不要求g是积性函数，但是构造的f往往是一个积性函数



## 常见数论函数的前缀和推导[#](https://www.cnblogs.com/Rubyonly233/p/14925239.html#常见数论函数的前缀和推导)

- $f(n)=μ(n),S(n)=∑_{i=1}^{n}μ(i)$

构造函数$g(n)=1(n)$，容易得到 $f∗g=ϵ$套用公式

![image-20230704102518905](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704102518905.png)

因为 $g(n)=1(n)$，所以 $g(n)$ 的前缀和可以直接 $O(1)$ 求，就可以直接套用模板做了

------

- $f(n)=φ(n),S(n)=∑_{i=1}^{n}φ(i)$

构造函数 g(n)=1(n)，容易得到 $f∗g=id_1$,套用公式

![image-20230704102705710](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704102705710.png)

同样可以套用模板去做

------

- $f(n)=μ(n)n,S(n)=∑_{i=1}^{n}μ(i)i$

构造函数 $g(n)=id_1(n)$

![image-20230704102913465](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704102913465.png)

接着套用公式

![image-20230704103018660](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103018660.png)

因为 $g(n)=id_1(n)$，所以可以 $O(1)$ 计算前缀和，同样可以套用模板去做

------

- $f(n)=φ(n)n,S(n)=∑_{i=1}^{n}φ(i)i$

构造函数 $g(n)=id_1(n)$

![image-20230704103206642](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103206642.png)

接着套用公式

![image-20230704103332197](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103332197.png)

然后套用模板去做就行了

------

- $f(n)=μ(n)n^2,S(n)=∑_{i=1}^{n}μ(i)i^2$

构造函数 $g(n)=id_2(n)$

![image-20230704103445526](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103445526.png)

接着套用公式

![image-20230704103503449](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103503449.png)

因为 $g(n)=id_2(n)$，所以前缀和直接就是 $n(n+1)(2n+1)/6$，同样可以套用模板去做

------

- $f(n)=φ(n)n^2,S(n)=∑_{i=1}^{n}φ(i)i^2$

构造 $g(n)=id_2(n)$

![image-20230704103643790](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103643790.png)

接着套用公式

![image-20230704103701978](C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230704103701978.png)



$∑g(d)$的求法跟上面一样，接着还是套用模板去做就行了


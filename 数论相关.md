# 数论相关

## 费马-欧拉定理

n,a为整数，若满足n，a互质，则：$a^{\phi(n)}\equiv1(mod n)$

Proof ：1~n中与n互质的数字有$\phi(n)$个,记为$x_1,x_2...x_{\phi{n}}$，考虑$m_i=a*x_i$

​		不难得到以下结论：

   * 任意$m_i$之间两两互质

   * $gcd(mi,n)=1$

     所以$m_i$与$x_i$之间存在一一对应的同余关系

     所以：$a^{\phi(n)}*x_1*x_2*...*x_{\phi(n)}\equiv x_1*x_2*...x_{\phi(n)}(mod n)$

     化简得到上述定理 

     $Q.E.D.$

推广：

* $a*a^{\phi(n)-1}\equiv1(mod n)$

​				**所以若a与n互质，则a关于n的乘法逆元就是$a^{\phi(n)-1}$**

* 特别的，当n为质数时，我们就得到了费马小定理：a,n互质且n为质数时，$a^{n-1}\equiv 1(mod n)$

---



## 拓展欧几里得算法

我们集中注意力在一个问题上：$ax+by=\gcd(a,b)$，这个不定方程如何解决？

首先存在 $ax_1+by_1=\gcd(a,b)$，其次当我们将方程用$ (a\bmod b)$和 a 来代入的时候可以发现，同时还存在 $bx_2+(a\bmod b)y_2=\gcd(b,a\bmod b)$。这时候我们找出了两个符合题目条件的式子。

在我们学习最大公约数时，欧几里得定理提出$ \gcd(a,b)=\gcd(b,a\bmod b)$，所以我们已经列出的两个式子右半边相等，于此相对地，左半边也相等，从而我们可以将这两个式子联立形成一个等式：

$ax_1+by_1=bx_2+(a\bmod b)$

我们还知道，对于一个取模式存在$ a\bmod b=a-\bigg(\left\lfloor\dfrac{a}{b}\right\rfloor\times b\bigg)$。

于是我们代入原式并化简：

$ax_1+by_1=bx_2+\bigg(a-\left\lfloor\dfrac{a}{b}\right\rfloor\times b\bigg)$

乘法分配律拆开括号：

$ax_1+by_1=bx_2+ay_2-\left\lfloor\dfrac{a}{b}\right\rfloor\times by_2$

提取公因式进行因式分解：

$ax_1+by_1=ay_2+b(x_2-\left\lfloor\dfrac{a}{b}\right\rfloor y_2)$

我们可以将两边简单地对等起来，得到一个具有普遍规律的式子：

$x_1=y_2\quad y_1=x_2-\left\lfloor\dfrac{a}{b}\right\rfloor y_2$

这个式子的意义是，我们可以缩减 *x* 和 *y* 的范围，递归求解了。

code:

```
int Exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }int d=Exgcd(b,a%b,x,y),t=x;
    x=y;y=t-(a/b)*y;
    return d;
}
```

或者可以这么写



```
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(!b){
		x=1;
		y=0;
		return a;
    }
    ll d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
```

### 拓展欧几里得定理求逆元

此时求a关于n的逆元，相当于求解方程$ax\equiv 1(mod n)$

显然，有$( k × n + 1 ) m o d n = 1$（k为任意常数），又因为$( ax ) m o d n = 1$，所以有$k × n + 1 = a × x $，也就是
$ax + kn = 1$

求解一下就好啦:smiley:

---



## 线性求逆元：

前面的求逆元的复杂度还是太高了，这里有一个线性时间复杂度的做法，可以求出1~n关于p的逆元。显然此时p与1~n的所有数都是互质关系

显然1的逆元为1.

考虑后面的数i，p可以表示为$k*i+j$ ，其中$k=\left \lfloor p/i \right \rfloor,j=pmod i$

我们不妨写成这样的形式：$k*i+j\equiv 0(modn)$

两边同时乘以$i^{-1}*j^{-1}$,得到：$k*j^{-1}+i^{-1}\equiv 0(mod n)$

化简得到：$i^{-1}\equiv -\left \lfloor p/i \right \rfloor*(pmod i)^{-1}(mod n)$ 

当然还有一个负号有点碍眼，我们可以将其处理掉：$-\left \lfloor p/i \right \rfloor\equiv (p-\left \lfloor p/i \right \rfloor)(mod p)$

显然$pmod i<i$,所以如果我们按从小到大的顺序求逆元的话，这是之前已经求好的值，所以该方法是合理的。

code：

```
inv[1]=1;
for(int i=2;i<p;++i)
{
	inv[i]=(p-p/i)*inv[p%i]%p;
}
```

---



## 推广：线性求任意n个数的逆元

上一种方法仍然有其局限性，如果求任意n个数的话，可能数字数不多，但是上限很大，这时复杂度就会很爆炸。

我们考虑n个数$a_i$ ，满足$1<=a_i<p$ 

构造$s_i=\prod_{k=1}^{i}a_i$,

我们可以在log(p)的复杂度内得到$s_n$的逆元（拓展欧几里得/快速幂都行），我们记为$inv_{s_n}$,不难发现$ (a\times b)^{-1}=a^{-1}\times b^{-1}$，所以我们将 $s_n$乘以 $a_n$的时候，$a_n$就会和其逆元抵消掉,我们就得到了$inv_{s_n-1}$ 

这样我们可以得到所有$s_n$的对应逆元，

显然有$s_{i-1}*inv_{s_i}=a_i^{-1}$

这样总体复杂度为$*O(n+log(p))$,接近线性复杂度，其能做的事情也是非常好了

---



## 中国剩余定理（CRT）

设正整数$m_1,m_2,...m_k$两两**互素**，有同余方程组

$x\equiv a_1(mod m_1)$

$x\equiv a_2(mod m_2)$

$x\equiv a_3(mod m_3)$

...

$x\equiv a_k(mod m_k)$

则对于任意的整数$a_1,a_2...a_k$，方程组有解

设$M=\prod_{i=1}^{n}m_i,并设M_i=M/m_i,设t_i为M_i模m_i在模M意义下的乘法逆元，即t_i=(M_imodm_i)^{-1}$

则方程组的通解为$x=a_1t_1M_1+a_2t_2M_2+...+a_kt_kM_k$

在模M的意义下，方程组有唯一解：$a=(\sum_{i-1}^{k}a_it_iM_i)mod M$



Proof

不妨从一个具体的问题开始考虑：$x\equiv 2(mod 3)$,$x\equiv 3 (mod 5),x\equiv 2mod(7)$

我们假设$n_1$是满足模3等于2的一个数，$n_2$是满足模5等于3的一个数，$n_3$是满足模7等于2的一个数。现在要满足所有条件，如果想要$n_1+n_2$满足模3等于2，那么条件就是$n_2$是3的倍数，接着如果我们想要$n_1+n_2+n_3$模3等于2的话，$n_3$也得满足模3等于2

那么，如果我们要使得$n_1+n_2+n_3$是满足方程组的一个解，需要的要求如下：

$n_1mod3=2$,且是5和7的公倍数

$n_2mod5 =3$,且是3和7的公倍数

$n_3mod 7=2$,且是3和5的公倍数

对于$n_1$，我们可以直接枚举5和7的公倍数，然后找到一个模3等于2的数字即可。当然其实可以更直接一点。我们先找5和7的公倍数中模3等于1的数字，然后再乘以2即可。为了实现这一步，我们可以找到2在模M意义下的逆元s，那么再用2去乘s就得到$n_1$了。同理可以得到任意$n_i$，具体做法就是取$M_i$，也就是M除以$m_i$ ,找到$M_imod m_i$的逆元，再乘以$a_i$就可以了

最后的一个解为$\sum n_i$，当然再模M的意义下解是唯一的，就是$(\sum n_i)mod M$

code

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n;
ll a[15];
ll b[15];
void exgcd(ll a,ll b,ll &x,ll &y){
	if(!b){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b,y,x);
	y-=a/b*x;
}
int main()
{
	cin>>n;
	ll t=1;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		t*=a[i];
		cin>>b[i];
	}
	ll ans=0;
	//Mi*ti+mi*y=1; 
	for(int i=1;i<=n;++i){
		ll g=t/a[i];//g=Mi;
		ll x,y; 
		exgcd(g,a[i],x,y);
		//得到x即为所求逆元
	//	x=x%a[i];
		if(x<0) x+=a[i];
	//	cout<<ans<<" "<<a[i]<<" "<<x<<endl;
		ans+=b[i]*g*x; 
		//cout<<ans<<endl;
	}
	ans%=t;
	cout<<ans<<endl;
	return 0;
}

```



---

拓展中国剩余定理

k个数$m_i$不满足两两互质时，方程组可能无解。

我们还是先考虑简单情况

$x\equiv a_1(mod m_1)$

$x\equiv a_2(mod m_2)$

它等价于：

$x=a_1+k_1*m_1$

$x=a_2+k_2*m_2$

化简得到：$k_1m_1-k_2m_2=a_2-a_1$

这是一个二元不定方程

此时如果$gcd(m_1,m_2)与(a_2-a_1)不是互质关系的话$，方程无解

否则可以求出一组解$k_1,k_2$,

然后将两个方程重新表示成x，这样就把两个方程合并了

最后这样做n-1次，就得到了一个方程，再求解即可

code

```
//excrt模板题 
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll k,a,r; 
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(!b){
		x=1;
		y=0;
		return a;
    }
    ll d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
ll ksc(ll x,ll y,ll z){
	ll ans=0;
	while(y){
		if(y&1) ans=(ans+x)%z;
		x=(x+x)%z;
		y>>=1;
	}
	return ans;
}
ll mod[100010];
ll yu[100010];
int main()
{
	cin>>k;
	
	for(int i=1;i<=k;++i){
		cin>>mod[i]>>yu[i];
	}
	ll x,y;
	ll t=mod[1],ans=yu[1];
	//t是前i个方程余数的lcm 
	for(int i=2;i<=k;++i){
		ll res=((yu[i]-ans)%mod[i]+mod[i])%mod[i];
		ll gcd=exgcd(t,mod[i],x,y);
		if(res%gcd){
			cout<<-1<<endl;
			return 0;
		}
		x=ksc(x,res/gcd,mod[i]);
		ans+=x*t;
		t=mod[i]/gcd*t;//t的更新 
		ans=((ans%t)+t)%t;//0~t之间满5足只有一个合法解，它就是 
	}
	cout<<ans<<endl;
	return 0;
}
```

---



## 升幂定理及其应用

定义：$V_p(x)为素数p整除x的最高幂次，若V_p(x)=\alpha,p^{\alpha}|x,且p^{\alpha +1}不整除x$

引理1：$$

---



## 整值函数

（这将会是惊人的一章）:smiley:

定义：

底：$\left \lfloor x \right \rfloor$,小于等于x的最大整数

顶：$\left \lceil x \right \rceil$,大于等于x的最小整数

[^本章最最最最基础最最最最最重要的东西:)]: 

## 类欧几里得算法

## 威尔逊定理

## 卢卡斯定理

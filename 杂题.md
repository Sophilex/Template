# 杂题

点分树

大意：
一棵树，每一个点有一个半径$r_i$，若i点被引爆，一秒后距离i点$\leq r_i$的点被引爆

$\forall i\in [2,n],$引爆i点之后，1点什么时候被引爆

思路：

考虑 **BFS**，每次要找所有未被扫过的点中能够炸到当前点 *i* 的所有点，相当于找所有未被标记的点 *j* 使

得 *dist*(*i, j*) *≤* $r_j$。建立点分树，那么就相当于对所有 *i* 在点分树上的祖先 *u*，找 *u* 点分树子树中所有未

被标记的点 *j*，使得 *dist*(*i, u*) *≤* *$r_j$* *−* *dist*(*j, u*)(因为在点分树下i,j之间的路径一定经过u)。直接对每个点 *u* 按照 $r_j$*−* *dist*(*j, u*) 将所有 *j* 排序即可。

每次扫指针找到所有需要求的点。

这题主要还是看一下另一种对距离的处理方法，具体见代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IL inline
#define pii pair<ll,ll>
#define endl '\n'
const ll inf=2e9;
const ll N=1e5+10;
struct ty
{
    ll t,l,next;
}edge[N<<1];
ll cn=0;
ll head[N];
namespace FastIOT{
    const int bsz=1<<18;
    char bf[bsz],*hed,*tail;
    inline char gc(){if(hed==tail)tail=(hed=bf)+fread(bf,1,bsz,stdin);if(hed==tail)return 0;return *hed++;}
    template<typename T>IL void read(T &x){T f=1;x=0;char c=gc();for(;c>'9'||c<'0';c=gc())if(c=='-')f=-1;
    for(;c<='9'&&c>='0';c=gc())x=(x<<3)+(x<<1)+(c^48);x*=f;}
    template<typename T>IL void print(T x){if(x<0)putchar(45),x=-x;if(x>9)print(x/10);putchar(x%10+48);}
    template<typename T>IL void println(T x){print(x);putchar('\n');}
}
using namespace FastIOT;
void add(ll a,ll b,ll c)
{
    edge[++cn].t=b;
    edge[cn].l=c;
    edge[cn].next=head[a];
    head[a]=cn;
}
ll n,m,a,b,c;
ll siz[N],mx[N],rt,nt,dep[N];
bool vis[N];
//节点是否已经分治过，在某次分治中距离为dis_vis[i]的节点是否存在
ll ans[110];
ll R[N];//radius
ll F[N];//虚树中的父亲节点
ll cur;//当前重心的dep
vector<pii> vt[N];//每一个点的子树中的信息
ll dis[20][N];
ll tim[N],rvis[N];
ll vt_siz[N];//每一个点的子树中的最后一个点，倒序枚举
queue<ll> q;
void find_rt(ll id,ll fa)
{
    siz[id]=1;mx[id]=0;
    for(int i=head[id];i!=-1;i=edge[i].next)
    {
        ll y=edge[i].t;
        if(y==fa||vis[y]) continue;
        find_rt(y,id);
        mx[id]=max(mx[id],siz[y]);
        siz[id]+=siz[y];
    }
    mx[id]=max(mx[id],nt-siz[id]);//这里是nt-siz[id],因为重心要在不同子树里面求
    if(mx[id]<mx[rt])
    {
        rt=id;
    }
}
void cal(ll id,ll fa)
{
    // cout<<id<<' '<<fa<<" "<<cur<<" "<<dis[cur][id]<<endl;
    vt[rt].push_back(make_pair(R[id]-dis[cur][id],id));
    for(int i=head[id];i!=-1;i=edge[i].next)
    {
        ll y=edge[i].t;
        if(y==fa||vis[y]) continue;
        dis[cur][y]=dis[cur][id]+edge[i].l;
        cal(y,id);
    }
}
void dfz_(ll id,ll p)//点分治
{
    F[id]=p;vis[id]=1;
    cur=dep[id];
    dis[cur][id]=0;
    cal(id,0);
    sort(vt[id].begin(),vt[id].end());//处理出了子树下的所有未被标记的节点到其的价值
    for(int i=head[id];i!=-1;i=edge[i].next)
    {
        ll y=edge[i].t;
        if(vis[y]) continue;
        //递归
        rt=0;mx[rt]=nt=siz[y];
        find_rt(y,0);find_rt(rt,0);//更新siz
        dep[rt]=dep[id]+1;
        dfz_(rt,id);
    }
}
void gt(ll id)
{
    ll now=id;
    while(id)
    {
        // cout<<id<<' '<<now<<" "<<dis[dep[id]][now]<<endl;
        while(vt_siz[id]>=0 && vt[id][vt_siz[id]].first>=dis[dep[id]][now])//虚树中now到id的距离 
        {                          //因为now必然在id的子树下面，所以其它与id同高的点的dep不会将dis[dep][id]更新掉 
            ll y=vt[id][vt_siz[id]].second;
            vt_siz[id]--;
            if(rvis[y]) continue;
            rvis[y]=1;
            tim[y]=tim[now]+1;

            q.push(y);
        }
        id=F[id];
    }
}
void init(ll n)
{
    cn=0;
    for(int i=0;i<=n+5;++i) head[i]=-1,siz[i]=0,mx[i]=0,dep[i]=0,R[i]=0,F[i]=0,vt[i].clear();
    rt=0,nt=0,cur=0;
    for(int i=0;i<=19;++i) for(int j=0;j<=n;++j) dis[i][j]=0;
    for(int i=0;i<=n+5;++i) tim[i]=inf,rvis[i]=0,vis[i]=0;
    while(!q.empty()) q.pop();
}
void solve()
{
    read(n);init(n);
    for(int i=2;i<=n;++i) read(R[i]);
    for(int i=1;i<n;++i)
    {
        read(a);read(b);read(c);
        add(a,b,c);
        add(b,a,c);
    }
    mx[0]=nt=n;
    find_rt(1,0);
    find_rt(rt,0);//更新siz数组，因为现在是以一个新的点为根节点
    dep[rt]=0;
    dfz_(rt,0);
    tim[1]=0,rvis[1]=1;
    for(int i=1;i<=n;++i) vt_siz[i]=vt[i].size()-1;
    q.push(1);
    while(!q.empty())
    {
        ll fr=q.front();
        q.pop();
        gt(fr);
    }
    for(int i=2;i<=n;++i)
    {
        cout<<((tim[i]==inf)?-1:tim[i])<<" ";
    }
    cout<<endl;
}
int main()
{
    ll t;cin>>t;while(t--)
    solve();
}
```



数位dp

[CF908G](https://blog.csdn.net/sophilex/article/details/131385426?spm=1001.2014.3001.5502)

求区间[L,R]内每一个数字在各数位排序后得到的数的和，答案对1e9+7取模

n<=1e700

思路：

这道题唯一的性质就是每一个数字的各个数位是升序排列的，然后我们可以发现这么一个结论：

每一个数字都可以被**最多9个由1组成的数**累加得到

举个例子,23349,可以按照如下方式拆分

<img src="C:\Users\26463\AppData\Roaming\Typora\typora-user-images\image-20230917100803071.png" alt="image-20230917100803071" style="zoom:50%;" />

最多只有9个是因为每一位最大只有9。然后我们看一下每一行的1的个数，其实也不难发现，第i行的1的个数=大于等于i的数字的个数，手模一下就可以验证了。

所以在第d行，计数字x中>=d的数字的个数为k，则x在第d行的贡献就是(10^k-1)/9(其实就是在构造k个1)

在此基础上，我们分9次来计算每一行的贡献。对于第d行，设dpi,j表示前i位，有j位>=d,直接做数位dp即可

所以此题的关键就是用1来组成数字，剩余的工作就都是很基础的了。不好想，只能说留个印象。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const ll N=1e5+10;
const ll mod=1e9+7;
string n;
ll a[710];
ll cnt=0;
ll dp[710][710]; 
ll p[710];
ll inv9;
ll ksm(ll x,ll y)
{
	ll ans=1;
	while(y)
	{
		if(y&1) ans=ans*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ans;
}
ll inv(ll x)
{
	return ksm(x,mod-2);
}
void init()
{
	inv9=inv(9); 
	ll now=1;
	for(int i=1;i<=710;++i)
	{
		p[i]=((now*10%mod)-1+mod)%mod*inv9%mod;
		now=now*10%mod;
	}
//	for(int i=1;i<=10;++i) cout<<p[i]<<endl;
}
ll dfs(ll x,ll op,ll pre,ll d)
{
	if(!x) return p[pre];
	if(!op&&dp[x][pre]!=-1) return dp[x][pre];
	ll tot=0;
	ll lim=op?a[x]:9;
	for(int i=0;i<=lim;++i)
	{
		if(i<d) tot=(tot+dfs(x-1,op&&i==lim,pre,d))%mod;
		else tot=(tot+dfs(x-1,op&&i==lim,pre+1,d))%mod;
	}
	if(!op) dp[x][pre]=tot;
	return tot;
}
ll f(string s)
{
	cnt=0;
	int len=s.size();
	for(int i=len-1;i>=0;--i)
	{
		a[++cnt]=s[i]-'0';
	}
	ll ans=0;
	for(int i=1;i<=9;++i)
	{
		memset(dp,-1,sizeof dp);
		ans=(ans+dfs(cnt,1,0,i))%mod;
	}
	return ans;
}
void solve()
{
	init();
	cin>>n;
	cout<<f(n)<<endl;
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	solve();
	return 0;
}
```


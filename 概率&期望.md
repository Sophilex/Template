感觉自己概率/期望方面的水平实在堪忧，新开一个坑记录一下训练日常，以及一些有意思的trick

---

[F. Jellyfish and EVA]([Problem - F - Codeforces](https://codeforces.com/contest/1875/problem/F))

给定一张n个点的DAG，每一个有向边的起点的序号<终点的序号。在某一个点尝试走下一个点时，AB两个人同时选择一条出边，如果选择相同，则前进至对应点，否则两条边被删去。现在已知A每次随机选边，问B在最优选择的决策下成功从1走到n的概率

$n\leq 5000$

注意到A每次随机选边，所以B每次应该优先选择成功概率最大的点对应的边。所以考虑$dp_{i,j}$表示有i个后继节点的时候选到排名为j的点的概率。考虑转移，首先我们第一次一定先选排名第1的点，成功的概率为$\frac{1}{i}$,否则失败，然后选排名为j的点，此时枚举A选的点来进行转移，这个点可以是排名在j之前的，也可以是j之后的，但不能是j，也不能是1，因为转移失败了

边界条件$dp_{1,1}=0,dp_{2,1}=0.5,dp_{2,2}=0$

之后按照权值全部把贡献加起来即可

```c++
void init(ll n)
{
    dp[1][1]=1;dp[2][1]=0.5;
    for(int i=3;i<=n;++i)
    {
        dp[i][1]=1.0/i;
        for(int j=2;j<=i;++j)
        {
            double p1=(j-2)*1.0/i;
            double p2=(i-j)*1.0/i;
            dp[i][j]=p1*dp[i-2][j-2]+p2*dp[i-2][j-1];
            //先选第一个，然后按照概率择优
        }
    }
}
vector<ll> vt[N];
ll n,m;
double ans[N];
bool cmp(ll a,ll b)
{
    return ans[a]>ans[b];
}
void solve()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) vt[i].clear(),ans[i]=0;
    for(int i=1;i<=m;++i)
    {
        ll a,b;cin>>a>>b;
        vt[a].push_back(b);
    }
    ans[n]=1;
    for(int id=n-1;id>=1;--id)
    {
        ll deg=vt[id].size();
        sort(vt[id].begin(),vt[id].end(),cmp);
        double ma=0,p=0;
        for(int i=0;i<deg;++i)
        {
            ll idx=vt[id][i];
            ma+=ans[idx]*dp[deg][i+1];
        }
        ans[id]=ma;
    }
    cout<<fixed<<setprecision(10)<<ans[1]<<endl;
}

```



[G. Jellyfish and Miku]([Problem - G - Codeforces](https://codeforces.com/contest/1875/problem/G))

0-n共n+1个点，$a_i$表示从i-1连向i的有向边的权值。站在i点，设其所有连边的权值和为$sum$,则走向权值为x的边的概率是$\frac{x}{sum}$,现在要求自己构造所有$a_i$，并满足$\sum a_i\leq m$，使得从0到n的期望步数最小，并求该值

$n,m\leq 3000$

设$dp_i$表示从0第一次走到i的期望步数，不难得到下式

$\large dp_i=dp_{i-1}+1+\frac{a_{i-1}}{a_{i-1}+a_i}(dp_{i}-dp_{i})$,意义就是从i-1走到i的时候，要不就是一步到位，要不就是撤回到i-2，那么按照dp的定义将差值补上即可

转化一下得到：$dp_i=dp_{i-1}+1+\frac{a_{i-1}}{a_i}(dp_{i-1}-dp_{i-2}+1)$

按照套路令$g_i=dp_i-dp_{i-1}$,不难得到$g_i=1+2\sum_{j=1}^{i-1}\frac{a_j}{a_i}$,由此$f_n=\sum_{i=1}^{n}g_i=n+2\sum_{i=2}^{n}\sum _{j=1}^{i-1}\frac{a_j}{a_i}$

到这里我们用一个前缀和，再来一个简单dp即可完成转移。但是复杂度是$O(nm^2)$,考虑优化

仔细观察$f_n$的递推式，不难得到$\forall j<i,a_j\leq a_i$,因为如果存在$j<i,a_j>a_i$的话，交换$a_i,a_j$，自己推一下就不难发现，值是一定会变小的。

由此$(n-i+1)a_i\leq m$,故$a_i\leq \frac{m}{n-i+1}$

这样对于每一个$a_i$的枚举的和就只有$mlogm$了，总体复杂度来到了$m^2logm$

```c++
void solve()
{
    double ans=1e18;cin>>n>>m;
    for(int i=2;i<=n;++i) for(int j=1;j<=m;++j) dp[i][j]=1e9;
    for(int i=2;i<=n;++i)
    {
        for(int a=1;a<m;++a)
        {
            for(int b=1;b+a<=m&&b<=m/(n-i+1);++b)
            {
                dp[i][a+b]=min(dp[i][a+b],dp[i-1][a]+1.0*a/b);
            }
        }
    }
    for(int i=1;i<=m;++i) ans=min(ans,dp[n][i]);
    cout<<n+2*ans<<endl;
}
```



[D. Flexible String Revisit]([Problem - 1778D - Codeforces](https://codeforces.com/problemset/problem/1778/D))

给定01串a,b，每次操作随机翻转a的某一位，问期望操作多少次使得a=b

不难发现每一位其实都是独立的，所以我们可以考虑$dp_i$表示当前a与b有i位不同，转移方程也很好写

$dp_i=\frac{i}{n}(dp_{i-1}+1)+\frac{n-i}{n}(dp_{i+1}+1),i\in [1,n-1],dp_0=0$

但是注意到这个式子需要从前面转移，也需要从后面转移，实际上是无法实现的，所以我们需要转化一下。

首先$dp_1=\frac{1}{n}(dp_0+1)+\frac{n-1}{n}(dp_2+1)=\frac{n-1}{n}dp_2+1$,由此我们可以用$dp_1$来表示$dp_2$

同理，$\forall i \in[2,n]$，$dp_i$都能用上式来转化成$dp_1$,这样我们就有了$n-1$个方程，最后$dp_n=dp_{i-1}+1$（显然）,我们就有了$n$个方程，那么将每一个$dp_i$用$dp_1$表示，再用最后一个方程求解一下即可

```c++
void solve()
{
    cin>>n;cin>>s1>>s2;
    for(int i=0;i<n;++i)
    {
        if(s1[i]!=s2[i]) cnt++;
    }
    coef[1][0]=1;
    for(ll i=1;i<n;++i)
    {
        coef[i+1][0]=((n*iv[n-i]%mod*coef[i][0]%mod-i*iv[n-i]%mod*coef[i-1][0]%mod)%mod+mod)%mod;
        coef[i+1][1]=((n*iv[n-i]%mod*coef[i][1]%mod-i*iv[n-i]%mod*coef[i-1][1]%mod-n*iv[n-i]%mod)%mod+mod)%mod;
    }
    ll dp1=((coef[n-1][1]-coef[n][1]+1)%mod+mod)%mod;
    ll fm=((coef[n][0]-coef[n-1][0])%mod+mod)%mod;
    dp1=dp1*inv(fm)%mod;

    cout<<(dp1*coef[cnt][0]%mod+coef[cnt][1])%mod<<endl;
}
```



有一棵 $n≤10^5$ 节点的树，每次随机选一个未删除的节点，删除它以及它的子树中的所有节点。当树为空时，期望经过了多少次删除操作

不妨将每一次删除操作的贡献固定在子树的根节点上，也就是说，一次删除操作之后，该根节点产生了1的贡献，其他节点没有贡献，也不会再有贡献。考虑一个点i被删除的条件，是它到根节点，一共$dep_i$个点中，在任意一个点执行了一次删除操作。那么点i能产生贡献的条件就是这一次删除操作恰好发生在它本身，概率显然就是$\frac{1}{dep_i}$.根据期望的线性性，答案就是$\sum\frac{1}{dep_i}$






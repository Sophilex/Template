# 矩阵与高斯消元

## 方程组消元

### $guass$消元（异或方程版）

```c++
const ll N=110;
//S:方程组，用bitsit存储
//all:每一个方程组的系数所在的位置
//len：方程组个数 
//now：当前处理到的方程 
//行列都是1索引
//n:变元个数
bitset<N> S[N];
ll o=0;
ll n=30;
int guass(ll all,ll len)
{
	int now=1,last=0;
	int cnt=0;
	for(int i=1;i<=n&&now<=len;++i)
	{
		int j=now;
		while(j<=len&&!S[j][i]) j++;
		if(j>len) continue;
		else cnt++;
		if(j!=now) swap(S[j],S[now]);
		for(int k=1;k<=len;++k)
		{
			if(k==now) continue;
			if(S[k][i]==0) continue;
			S[k]^=S[now];
		}
		now++; 
	}
//	for(int i=0;i<len;++i)
//	{
//		cout<<S[i]<<endl;
//	}
	for(int i=now;i<=len;++i)
	{
		if(S[i][all]==1) return 0;//方程无解
	}
	return 1;
}
```

$eg:$

5*6矩阵，每一个格子有亮暗初始状态，按下一个按钮会使自身以及周围四个格子改变亮暗状态。求使所有格子为暗的方案

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const ll N=110;
//S:方程组，用bitsit存储
//all:每一个方程组的系数所在的位置
//len：方程组个数 
//now：当前处理到的方程 
//行列都是1索引
//n:变元个数
bitset<N> S[N];
ll o=0;
ll n=30;
int guass(ll all,ll len)
{
	int now=1,last=0;
	int cnt=0;
	for(int i=1;i<=n&&now<=len;++i)
	{
		int j=now;
		while(j<=len&&!S[j][i]) j++;
		if(j>len) continue;
		else cnt++;
		if(j!=now) swap(S[j],S[now]);
		for(int k=1;k<=len;++k)
		{
			if(k==now) continue;
			if(S[k][i]==0) continue;
			S[k]^=S[now];
		}
		now++; 
	}
//	for(int i=0;i<len;++i)
//	{
//		cout<<S[i]<<endl;
//	}
	for(int i=now;i<=len;++i)
	{
		if(S[i][all]==1) return 0;//方程无解
	}
	return 1;
}
ll cn=0;
ll dir[][4]={{1,0},{-1,0},{0,1},{0,-1}};
bool inmap(ll x,ll y)
{
	return x>=1&&y>=1&&x<=5&&y<=6;
}
ll gt(ll x,ll y)
{
	return y+(x-1)*6;
}
void solve()
{
	memset(S,0,sizeof S); 
	cn=0;
	for(int i=1;i<=5;++i)
	{	
		for(int j=1;j<=6;++j)
		{
			ll a;cin>>a;
			S[++cn][31]=a;
			S[cn][gt(i,j)]=1;
			for(int k=0;k<4;++k)
			{
				ll xx=i+dir[k][0];
				ll yy=j+dir[k][1];
				if(!inmap(xx,yy)) continue;
				S[cn][gt(xx,yy)]=1;
			}
		}
	}
	
    cout<<"PUZZLE #"<<++o<<endl;
	guass(31,30);

	for(int i=1;i<=cn;++i)
	{
		cout<<S[i][31]<<" ";
		if((i)%6==0) cout<<endl;
	}
	
}
int main()
{
//	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	ll t;cin>>t;while(t--)
	solve();
}
```



### $Guass$消元（普通方程版）

时间复杂度n^3 

可以判断是无解还是无数解 

0索引

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define ll int
const double eps=1e-6;
const ll N=110;
double S[N][N];
double x[N];
ll n;
int guass(int n, int m)//方程数，未知数个数 
{
    int c=0,r,maxr; 
    for(r=0;r<n&&c<m;r++,c++)
	{
        maxr=r;
        for(int i=r+1;i<n;i++)
		{
            if(abs(S[i][c])>abs(S[maxr][c]))
                maxr=i;
        }
        if(maxr!=r) swap(S[r], S[maxr]);
        if(fabs(S[r][c])<eps)
		{
            r--;
            continue;
        }
        for(int i=r+1;i<n;i++)
		{
            if(fabs(S[i][c])>eps)
			{
                double k=S[i][c]/S[r][c];
                for(int j=c;j<m+1;j++) S[i][j]-=S[r][j]*k;
                S[i][c]=0;
            }
        }
    } 
    for(int i=r;i<m;i++)
	{
    	if(fabs(S[i][c])>eps) return -1;//无解
    }    
    if(r<m) return m-r;//返回自由元个数
    for(int i=m-1;i>=0;i--)
	{
        for(int j=i+1;j<m;j++) S[i][m]-=S[i][j]*x[j];
        x[i]=S[i][m]/S[i][i];
    }
    return 0;//有唯一解
}
void solve()
{
	cin>>n;
	for(int i=0;i<n;++i)
	{
		for(int j=0;j<n+1;++j)
		{
			cin>>S[i][j];
		}
	}
	int ans=guass(n,n);
	if(ans!=0) cout<<"No Solution"<<endl;
	else for(int i=0;i<n;++i) cout<<fixed<<setprecision(2)<<x[i]<<endl;
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	solve();
	return 0;
}
```

### 高斯-约旦消元

复杂度n^3

只能判断是否有唯一解，无法判断究竟是无解还是无数解

但是精度高 

1索引

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define ll int
const double eps=1e-6;
const ll N=110;
double S[N][N];
ll n;
int pl;
int guass(int n, int m)//方程数，未知数个数 
{
    for(int i=1;i<=n;i++)
    {
        pl=i;
        for(int j=i;j<=m;j++) {
        	if(S[j][i]>S[pl][i]) pl=i;
		}                                     
        if(S[pl][i]==0) {return 0;} //无解或有自由元   
        for(int j=1;j<=m+1;j++)
        swap(S[i][j],S[pl][j]);
        double k=S[i][i];
        for(int j=1;j<=m+1;j++)
        S[i][j]=S[i][j]/k; 
        for(int j=1;j<=n;j++)
        {
            if(i!=j)
            { 
                double ki=S[j][i];
                for(int w=1;w<=m+1;w++)
                S[j][w]=S[j][w]-ki*S[i][w];
            }
        }
    }
}
void solve()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n+1;++j) cin>>S[i][j];
	}
	int ans=guass(n,n);
	if(ans==0) cout<<"No Solution"<<endl;
	else for(int i=1;i<=n;++i) cout<<fixed<<setprecision(2)<<S[i][n+1]<<endl;
}
int main()
{
ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	solve();
	return 0;
}
```

### Gauss消元求行列式

复杂度$n^3$

```c++
int z[N][N];int n;

inline int guass(){
	int x=1;
	for(int a=1;a<=n;a++)
		for(int b=a+1;b<=n;b++)
			while(z[b][a]!=0){
				int k=z[a][a]/z[b][a];
				for(int c=1;c<=n;c++) z[a][c]-=z[b][c]*k;
				for(int c=1;c<=n;c++) swap(z[a][c],z[b][c]);
				x=-x;
			}
	for(int i=1;i<=n;i++) x*=z[i][i];
	return x;
}

```



## 矩阵快速幂

```c++
const ll mod=1e9+7;
ll n,t;
struct mat
{
	ll m[110][110];//结构体存矩阵 
};
mat a,e;//输入输出矩阵
mat mul(mat x,mat y,ll n) //矩阵乘法，n代表矩阵的规模 
{
	mat c;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			c.m[i][j]=0;//初始化 
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			for(int k=1;k<=n;++k)
			{
				c.m[i][j]=c.m[i][j]%mod+x.m[i][k]%mod*y.m[k][j]%mod;
			}
		}
	}
	return c;
} 

ll qpow(mat x,ll y,ll mod)
{
	mat ans=e;//一般是一个对角为1的初始矩阵 ，记得初始化 
	//x是变换矩阵 
	while(y)
	{
		if(y&1) ans=mul(ans,x,6);
		x=mul(x,x,6);
		y>>=1;
	}
	return (ans.m[1][1]+ans.m[1][3]*8+ans.m[1][4]*4+ans.m[1][5]*2+ans.m[1][6])%mod;
    //之前得到的是变换矩阵的y次幂，最后将其与初始矩阵相乘即可 
}
```


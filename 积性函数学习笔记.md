# 积性函数学习笔记

重学了一遍积性函数，涉及积性函数的递推，反演，杜教筛等

## 积性函数

### 定义：

对于一个$\mathbb{N}\Rightarrow \mathbb{R}$的函数f

$\forall i,j,(i,j)=1\Rightarrow f(i)*f(j)=f(i*j)$，则f称为积性函数

特别的，如果$\forall i,j,f(i)*f(j)=f(i*j)$,则f称为完全积性函数

一些典型的积性函数：

$\epsilon (i)=[i=1]$

$id_k(i)=i^k$,它也是一个完全积性函数，证明显然

$\phi(i)$ 欧拉函数

$\mu(i)$ 莫比乌斯函数

1(i)=1 

$\sigma(i)$ 约数个数

$\Delta(i)$ 约数和

下面挑两个简单证明一下其为什么是积性函数

---

首先，对于n，我们可以将其进行质因数分解，

$n=\prod_{i}p_i^{\alpha_i}$

考虑约数个数函数$\sigma(n)=\prod_{i}(\alpha_i+1)$

如果m,n互质，显然它们不含相同的质因子

我们记$n=\prod_{i}p_i^{\alpha_i}$,$m=\prod_{j}q_i^{\beta_i}$,则$m*n=\prod_{i}p_i^{\alpha_i}\prod_{j}q_j^{\beta_j}$

有$\sigma(n)=\prod_{i}(\alpha_i+1),\sigma(m)=\prod_{i}(\beta_i+1)$

$\sigma(m*n)=\prod_{i}(\alpha_i+1)*\prod_{j}(\beta_j+1)=\sigma(n)*\sigma(m)$

得证

再来看看约数和函数$\Delta(n)=\prod_{i}(p_i^0+p_i^1+...+p_i^{\alpha_i})$

与上一个分析一样，因为互质的两个数字没有相同的质因子，那么直接带入就有同样的答案。

后面碰到各种各样的函数的时候，采用类似的方法基本上都可以分析出来其是否是一个积性函数

### 性质



* 如果两个$\mathbb{N}\Rightarrow \mathbb{R}$的函数$f,g$都为积性函数，则其乘积也为积性函数：

  令$h(i)=f(i)*g(i)$,考虑$(m,n)=1$

  $h(mn)=f(mn)g(mn)=f(m)f(n)g(m)g(n)=(f(m)g(m))(f(n)g(n))$

  得证

* 如果两个$\mathbb{N}\Rightarrow \mathbb{R}$的函数$f,g$都为积性函数，则其范德蒙德卷积也为积性函数

  证明在后文给出，这是一个很重要的结论，后面各种题目里都会用到这个性质

* 如果$\mathbb{N}\Rightarrow \mathbb{R}$的函数$f$为积性函数,对于$n=\prod_{i}p_i^{\alpha_i}$,$f(n)=\prod_{i}f(p_i^{\alpha_i})$

  这是显然的，因为不同质数的幂次之间显然互质

  

### 线性推积性函数

我们都知道欧拉筛可以线性求质数，其原理就是用每一个合数的最小质因子来筛掉它。利用这一特点我们可以完成线性得到积性函数

因为积性函数的各个质因子独立，所以我们可以将其拆分为若干个函数之积

记$cal(x,num)$为求f值的函数，x为素数，$num$为其次数。利用此函数，加上整数的质因子拆分，我们在理论上就已经可以求得任意数的f值了。再用cn数组用于记录数字的最小质因子对应的次数。为什么是最小质因子？因为每一个合数只会被其最小质因子筛到，所以我们维护其它质因子也没有意义。

对于所有的积性函数$f，f[1]=1$恒成立，不然就不满足上述积性函数的性质了

下面给出模板，一些解释也都放在里面了

```c++
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll cal(ll x,ll num)
{
	//x为素数，num为其次数 
}
void jixing(ll n)
{
	f[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i])
		{
			p[++cnt]=i;
			f[i]=cal(i,1);
			cn[i]=1;
		}
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			//i*p[j]的最小质因子一定为p[j] 
			if(i%p[j]==0)
			{
				//i*p[j]的最小质因子的次数=i对应的p[j]的次数+1 
				cn[i*p[j]]=cn[i]+1;
				//首先去掉f[i]中p[j]对应的值,然后更新当前次数下p[j]对应的值 
				f[i*p[j]]=f[i]/cal(p[j],cnt[i])*cal(p[j],cnt[i]+1); 
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*cal(p[j],1);
		}
	}
} 
```

在此基础上，我们可以看看如何线性求约数函数$\sigma(n)$

$f(n)=\sigma(\prod_{i}p_i^{\alpha_i})=\prod_{i}(\alpha_i+1)$,故枚举i的时候

若是质数，$f(i)=2,cn[i]=1$

枚举倍数的时候，$f(i*p[j])=\left\{\begin{matrix}
f(i)*2 & imodp[j]\neq0 \\ 
f[i]/(cn[i]+1)*(cn[i]+2) & imodp[j]=0
\end{matrix}\right.$

$cn[i]=\left\{\begin{matrix}
1 & imodp[j]\neq0 \\ 
cn[i]+1 & imodp[j]=0
\end{matrix}\right.$

模板

```c++
ll vis[N];
ll cn[N];//记录最小质因子的对应次数,显然质数x的cn值为1 
ll p[N];
ll f[N];
ll cnt=0;
void F(ll n)
{
	f[1]=1;
	cn[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i]) 
		{
			f[i]=2;
			p[++cnt]=i;
			cn[i]=1;
		}	
		for(int j=1;j<=cnt&&i*p[j]<=n;++j)
		{
			vis[i*p[j]]=1;
			if(i%p[j]==0)
			{
				cn[i*p[j]]=cn[i]+1;
				f[i*p[j]]=f[i]/(cn[i]+1)*(cn[i]+2);
				break;
			}
			cn[i*p[j]]=1;
			f[i*p[j]]=f[i]*2;
		}
	}	
} 
```

对于欧拉函数$\phi(n)=\phi(\prod_{i}p_i^{\alpha_i})=\prod_{i}(p_i-1)p_i^{\alpha_i-1}$(证明有一点繁琐，这里不予展示，可以自行百度)，它也是一个积性函数，所以线性求欧拉函数的时候：

若是质数，$\phi(i)=i-1$

枚举倍数的时候，$\phi(i*p[j])=\left\{\begin{matrix}
\phi(i)*(p[j]-1) & imodp[j]\neq0 \\ 
\phi(i)*p[j] & imodp[j]=0
\end{matrix}\right.$

模板

```c++
void F(ll n)
{
	phi[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i]) p[++cnt]=i,phi[i]=i-1;
		for(int j=1;(j<=cnt)&&(i*p[j]<=n);++j)
		{
			vis[i*p[j]]=1;
			if(i%p[j]==0)
			{
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*(p[j]-1);
		}
}
```

### 一些套路推导

* $\sum_{i=1}^{n}\frac{lcm(i,n)}{n}$

  $=\sum_{d|n}\sum_{i=1}^{n}\frac{i}{d}[(i,n)=d]$

  $=\sum_{d|n}\sum_{i=1}^{n}i[(\frac{i}{d},\frac{n}{d})=d]$

  $=\sum_{d|n}\sum_{i=1}^{\frac{n}{d}}i[(i,\frac{n}{d})=1]$

  $=\sum_{d|n}\sum_{i=1}^{d}i[(i,d)=1]$ 因为这里枚举d与枚举n/d等价

  $=\sum_{d|n}\frac{d\phi(d)}{2}$

  关于最后一步的证明：$\sum_{i=1}^{d}i[(i,d)=1]=\frac{1}{2}(\sum_{i=1}^{d}i[(i,d)=1]+\sum_{i=1}^{d}(d-i)[(d-i,d)=1])$ 正反枚举一遍

  又因为$(i,d)=(d-i,d)$，故$\sum_{i=1}^{d}i[(i,d)=1]=\frac{1}{2}\sum_{i=1}^{d}d[(i,d)=1]=\frac{d}{2}\phi(d)$

* 欧拉反演

  $id=\phi*1$其实也就是前面提到的，它确实很有用

### 例题

[$cf757 Bash Plays with Functions$](https://codeforces.com/contest/757/problem/E )

给定函数f，$f_r(n)=\left\{\begin{matrix}
\sum_{uv=n}[(u,v)=1] & r=0 \\ 
\sum_{uv=n}\frac{f_{r-1}(u)+f_{r-1}(v)}{2} & r\geq1 
\end{matrix}\right.$

对于给定的r,n,求$f_r(n)$

不妨先来分析一下$f_0(n):$

对于$n=p_1^{\alpha_1}p_2^{\alpha_2}...p_k^{\alpha_k}$

考虑$u=p_1^{\beta_1}p_2^{\beta_2}...p_k^{\beta_k},v=p_1^{\alpha_1-\beta_1}p_2^{\alpha_2-\beta_2}...p_k^{\alpha_k-\beta_k}$,此时有$uv=n$

为了保证$(u,v)=1$，我们不难发现$\beta_i$只能等于$\begin{Bmatrix}
0, & \alpha_i
\end{Bmatrix}$,

所以$f_0(n)=2^k$,不要忘记这是一个积性函数

$r\geq 1$时，不难发现$f_r(n)=\sum_{u|n}f_{r-1}(n)$,所以$f_r(n)=f_{r-1}(n)*1$,这里$*$代表迪利克雷卷积，所以$f_r(n)$也是一个积性函数。

那么问题就简单很多了，对于$f_r(n)$,我们只需要对求出n的每一个质因子的$f_r(p_i)$,然后乘起来即可。对于质数p,$f_0(p)=2,f_1(p)=\sum_{u|p}f_0(p)$,我们发现$f_0(p)$已经是一个与p无关的数字了，所以$\forall p_i,p_j,f_r(p_i)=f_r(p_j)$恒成立。故考虑$dp_{i,j}$表示$f_i(p^j),dp_{i,j}=\sum_{k=1}^{j}dp_{i-1,k}$，可以前缀和优化。同时j不超过20，所以时间复杂度也可以接受

code

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=1e6+10;
const ll mod=1e9+7;
int n,r;
ll dp[N][30];
int LP[N];
void init()
{
    for(int i=1;i<=25;++i) dp[0][i]=2;
        dp[0][0]=1;
    for(int i=1;i<=1000000;++i)
    {
        dp[i][0]=1;
        ll sum=1;
        for(int j=1;j<=20;++j)
        {
            dp[i][j]=(dp[i-1][j]+sum)%mod;
            sum=(sum+dp[i-1][j])%mod;

        }
    }
}
void iinit()
{
    LP[1]=1;
    for(int i=2;i<=1000000;++i)
    {
        if(!LP[i])
        {
            for(int j=i;j<=1000000;j+=i) LP[j]=i;
        }
    }
}
void solve()
{
    cin>>r>>n;
    ll ans=1;

    // for(ll i=2;i*i<=n;++i)
    // {
    //     if(n%i) continue;
    //     ll cnt=0;
    //     while((n%i)==0)
    //     {
    //         cnt++;
    //         n/=i;
    //     }
    //     ans=ans*dp[r][cnt]%mod;
    // }

    while(n!=1)
    {
       int cnt=0,p=LP[n];
       while(n%p==0) n/=p,cnt++;
       ans=(ans*dp[r][cnt])%mod;
    }

    cout<<ans<<endl;
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cin.tie(0);
    init();iinit();
    ll t;cin>>t;while(t--)
    solve();
    return 0;
}

```

## 积性函数的反演

相比于上一块，这一块在竞赛中的应用会更加多一些。

重新讨论一下一开始有提到的迪利克雷卷积

所谓**狄利克雷卷积**，是定义在**数论函数**（ Z+→C 的函数）间的一种二元运算，可这样定义:$h(n)=\sum_{d|n}f(d)g(n/d)$,h称为f与g的迪利克雷卷积。后面我们统一用$*$来表示该卷积,即$(f*g)(n)=\sum_{d|n}f(d)g(n/d)$

**性质**：两个积性函数的迪利克雷卷积也是积性函数

**一个很重要的结论**：若$f=g*1$，则$g=f*\mu$.，相当于$\mu$是1的逆元

#### 一些常见的$Dirichlet$卷积：

* $\epsilon=\mu *1$:

  展开：$[n=1]=\sum_{d|n}\mu(d)$

  $Proof: 1=\sum[n=1]\Rightarrow 1(n)=\sum_{d|n}\epsilon(d) \Rightarrow 1(n)=1(n)*\epsilon(n) \Rightarrow \epsilon=\mu*1$

  ​                这里带入了上面讲的结论

* $id=\phi*1$ 证明略

* $\phi=\mu*id$(其实就是上式的反演)

这些反演一般用在杜教筛里比较多，可以实现积性函数求前缀和。但是莫比乌斯函数与欧拉函数的反演在一般的计数问题中也比较常见

#### 杜教筛

对于积性函数$f(n)$,我们可以在$O(n^{\frac{2}{3}})$的复杂度内求解其前缀和













